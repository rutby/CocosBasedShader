{
  "ver": "1.0.25",
  "uuid": "7d6c0fc6-539e-4791-87a9-f2018fc1a248",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mediump mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\nvoid main () {\n    vec4 pos = vec4(a_position, 1);\n    pos = cc_matViewProj * pos;\n    v_uv0 = a_uv0;\n    v_color = a_color;\n    gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform highp vec4 cc_time;\nvarying vec4 v_color;\nvarying vec2 v_uv0;\nuniform sampler2D texture;\nuniform sampler2D noiseTexture;\nuniform float rainSpeed;\nuniform float rainForce;\nfloat circle(float scale, vec2 pos, float radius) {\n    float b1 = radius * scale;\n    float b2 = radius * scale - 0.01;\n    float d = length(pos - 0.5);\n    float s1 = step(d, b1);\n    float s2 = step(b2, d);\n    return step(2., s1 + s2);\n}\nvec4 grid(float splitCount, vec2 offset) {\n    float piece = 1. / splitCount;\n    vec2 newuv = v_uv0 + offset;\n    float gx = floor(newuv.x * splitCount) / splitCount;\n    float gy = floor(newuv.y * splitCount) / splitCount;\n    float nx = (newuv.x - gx) / piece;\n    float ny = (newuv.y - gy) / piece;\n    return vec4(nx, ny, gx, gy);\n}\nfloat hash12(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat ripple(float splitCount) {\n    float gy = floor(v_uv0.y * splitCount) / splitCount / 4.0;\n    vec4 newuv = grid(splitCount, vec2(gy, 0.));\n    float percent = clamp((rainForce - 0.9) / 0.15 + 1., 0., 2.) - 1.;\n    float rand = hash12(vec2(newuv.z, newuv.w));\n    float t = fract(cc_time.x + rand);\n    float p = floor((cc_time.x + rand));\n    float radius = rand * 0.3 + 0.1;\n    float rippleForce = percent * 50.;\n    radius *= step(50. + rippleForce, mod(floor(rand * (1. + p * 43758.5453) * 1000.), 100.));\n    float r = circle(t, vec2(newuv.x, newuv.y), radius);\n    r *= (1. - t) * 0.7 + 0.3;\n    return r;\n}\nvoid main () {\n    vec4 o = texture2D(texture, vec2(v_uv0.x, v_uv0.y));\n    vec2 rain_uv = vec2(v_uv0.x, v_uv0.y * 0.02 - cc_time.x * rainSpeed);\n    rain_uv.x += v_uv0.y * 0.3;\n    vec4 col_rain = texture2D(noiseTexture, rain_uv);\n    float f = (col_rain.r - rainForce *  col_rain.g - rainForce *  col_rain.b);\n    f = smoothstep(0., 0.05, f);\n    o.rgb += vec3(f);\n    o.rgb += ripple(10.0);\n    gl_FragColor = o;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  mediump mat4 cc_matViewInv;\n  mediump mat4 cc_matProj;\n  mediump mat4 cc_matProjInv;\n  mediump mat4 cc_matViewProj;\n  mediump mat4 cc_matViewProjInv;\n  mediump vec4 cc_cameraPos;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin vec2 a_uv0;\nout vec2 v_uv0;\nvoid main () {\n    vec4 pos = vec4(a_position, 1);\n    pos = cc_matViewProj * pos;\n    v_uv0 = a_uv0;\n    v_color = a_color;\n    gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  mediump mat4 cc_matViewInv;\n  mediump mat4 cc_matProj;\n  mediump mat4 cc_matProjInv;\n  mediump mat4 cc_matViewProj;\n  mediump mat4 cc_matViewProjInv;\n  mediump vec4 cc_cameraPos;\n};\nin vec4 v_color;\nin vec2 v_uv0;\nuniform sampler2D texture;\nuniform sampler2D noiseTexture;\nuniform Rain {\n    float rainSpeed;\n    float rainForce;\n    float xStep;\n};\nfloat circle(float scale, vec2 pos, float radius) {\n    float b1 = radius * scale;\n    float b2 = radius * scale - 0.01;\n    float d = length(pos - 0.5);\n    float s1 = step(d, b1);\n    float s2 = step(b2, d);\n    return step(2., s1 + s2);\n}\nvec4 grid(float splitCount, vec2 offset) {\n    float piece = 1. / splitCount;\n    vec2 newuv = v_uv0 + offset;\n    float gx = floor(newuv.x * splitCount) / splitCount;\n    float gy = floor(newuv.y * splitCount) / splitCount;\n    float nx = (newuv.x - gx) / piece;\n    float ny = (newuv.y - gy) / piece;\n    return vec4(nx, ny, gx, gy);\n}\nfloat hash12(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat ripple(float splitCount) {\n    float gy = floor(v_uv0.y * splitCount) / splitCount / 4.0;\n    vec4 newuv = grid(splitCount, vec2(gy, 0.));\n    float percent = clamp((rainForce - 0.9) / 0.15 + 1., 0., 2.) - 1.;\n    float rand = hash12(vec2(newuv.z, newuv.w));\n    float t = fract(cc_time.x + rand);\n    float p = floor((cc_time.x + rand));\n    float radius = rand * 0.3 + 0.1;\n    float rippleForce = percent * 50.;\n    radius *= step(50. + rippleForce, mod(floor(rand * (1. + p * 43758.5453) * 1000.), 100.));\n    float r = circle(t, vec2(newuv.x, newuv.y), radius);\n    r *= (1. - t) * 0.7 + 0.3;\n    return r;\n}\nvoid main () {\n    vec4 o = texture(texture, vec2(v_uv0.x, v_uv0.y));\n    vec2 rain_uv = vec2(v_uv0.x, v_uv0.y * 0.02 - cc_time.x * rainSpeed);\n    rain_uv.x += v_uv0.y * 0.3;\n    vec4 col_rain = texture(noiseTexture, rain_uv);\n    float f = (col_rain.r - rainForce *  col_rain.g - rainForce *  col_rain.b);\n    f = smoothstep(0., 0.05, f);\n    o.rgb += vec3(f);\n    o.rgb += ripple(10.0);\n    gl_FragColor = o;\n}"
      }
    }
  ],
  "subMetas": {}
}